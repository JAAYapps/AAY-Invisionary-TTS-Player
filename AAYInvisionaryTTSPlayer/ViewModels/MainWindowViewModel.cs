#nullable enable
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media;
using Avalonia.Platform.Storage;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using AAYInvisionaryTTSPlayer.Models;
using AAYInvisionaryTTSPlayer.Services.ClipboardService;
using AAYInvisionaryTTSPlayer.Services.ErrorHandler;
using AAYInvisionaryTTSPlayer.Services.FileService;
using AAYInvisionaryTTSPlayer.Services.PlayerService;
using AAYInvisionaryTTSPlayer.Services.SettingsService;
using AAYInvisionaryTTSPlayer.Services.TTSService;
using NAudio.Lame;
using NAudio.Wave;
using OggVorbisEncoder;

namespace AAYInvisionaryTTSPlayer.ViewModels;

// Mark the class as partial for source generators
public partial class MainWindowViewModel : ViewModelBase, IDisposable
{
    // --- Injected Services ---
    private readonly IPlayer? player;
    private readonly IErrorHandler? handler;
    private readonly IClipboardService? clipboardService;
    private readonly ITtsService? ttsService;
    private readonly IFileService? fileService;
    private readonly ISettingsService? settingsService;
    private readonly CancellationTokenSource cts = new();
    private readonly IClipboardMonitorService? clipboardMonitor;
    private readonly UserSettings? settings;
    
    // --- State Fields ---
    private bool stopped = true;

    // --- Public Collections (No change needed) ---
    private Dictionary<string, string> Voices { get; } = new();
    private Dictionary<string, string> SaveFileAudioNames { get; } = new();
    public ObservableCollection<string> VoiceList { get; } = new();
    
    private bool loading = false;
    
    // --- Observable Properties (Generated by CommunityToolkit) ---
    [ObservableProperty]
    private string voiceName = "Kusal (Male)";
    
    [ObservableProperty]
    private bool customVoice;
    
    private string sampleVoice = string.Empty;

    public string SampleVoice
    {
        get => (string.IsNullOrEmpty(sampleVoice) ? VoiceName : sampleVoice.Split('/').LastOrDefault()?.Split('\\').LastOrDefault()) ?? VoiceName;
        set
        {
            if (SetProperty(ref sampleVoice, value))
                sampleVoice = value;
        }
    }

    [ObservableProperty]
    private string volumeStatus = "Volume: 100";

    [ObservableProperty]
    private string rateStatus = "Rate: 1";

    [ObservableProperty]
    private string wordStatus = "Word: ";

    [ObservableProperty]
    private bool isPlayerViewExpanded = true;

    [ObservableProperty]
    private StreamGeometry? toggleIconData;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(PlayTtsCommand))]
    private bool canPlay = true;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(StopTtsCommand))]
    private bool canStop;

    [ObservableProperty]
    private string playButtonText = "Play";

    [ObservableProperty]
    private bool isClipboardMonitoringEnabled = true;
    
    // --- Properties with Custom Logic ---
    private float volume = 100;
    public float Volume
    {
        get => volume;
        set
        {
            if (SetProperty(ref volume, value))
            {
                if (player != null) player.Volume = value;
                VolumeStatus = $"Volume: {value}";
            }
        }
    }

    private float rate = 1;

    public float Rate
    {
        get => rate;
        set
        {
            if (SetProperty(ref rate, value))
            {
                if (player != null) player.Pitch = value;
                RateStatus = $"Rate: {value}";
            }
        }
    }

    // Parameterless constructor FOR THE DESIGNER ONLY.
    public MainWindowViewModel()
    {
        // Initialize properties with design-time sample data.
        volumeStatus = "Volume: 75";
        rateStatus = "Rate: 1.2";
        wordStatus = "Word: designing...";
        playButtonText = "Play";
        CanPlay = false; // Disable buttons in the designer.

        // Populate the voice list so the ComboBox has items in the preview.
        PopulateVoices(false);
        VoiceName = VoiceList.FirstOrDefault() ?? "Kusal (Male)";
        CustomVoice = true;
        UpdateToggleIcon();
    }
    
    // --- Constructor (with Dependency Injection) ---
    public MainWindowViewModel(
        IPlayer? player, 
        IClipboardService? clipboardService, 
        ITtsService? ttsService,
        IFileService? fileService, 
        ISettingsService? settingsService,
        IOptions<UserSettings> userSettings,
        IErrorHandler? errorHandler,
        IClipboardMonitorService? clipboardMonitor)
    {
        // Store injected services
        this.player = player;
        this.clipboardService = clipboardService;
        this.ttsService = ttsService;
        this.fileService = fileService;
        this.settingsService = settingsService;
        this.handler = errorHandler;
        this.clipboardMonitor = clipboardMonitor;
        
        settings = userSettings.Value;
        
        IsClipboardMonitoringEnabled = settings.AutoRead;

        var clipboardMonitorService = this.clipboardMonitor;
        if (clipboardMonitorService != null)
        {
            clipboardMonitorService.IsEnabled = IsClipboardMonitoringEnabled;

            clipboardMonitorService.ClipboardTextChanged += OnClipboardTextChanged;

            clipboardMonitorService.StartMonitoring(cts.Token);
        }
        
        PopulateVoices(settings.ChosenBackend != "EchoGarden");
        
        CustomVoice = settings.ChosenBackend != "EchoGarden";
        
        VoiceName = VoiceList.FirstOrDefault() ?? "Kusal (Male)";
        
        // Start the modern polling mechanism
        StartStatusPolling(cts.Token);
        CanPlay = true;
        UpdateToggleIcon();
    }

    private void OnClipboardTextChanged(string text)
    {
        Console.WriteLine("Clipboard changed, starting playback...");
        Dispatcher.UIThread.Post(async void () =>
        {
            try
            {
                await PlayTtsAsync();
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
        });
    }
    
    partial void OnIsPlayerViewExpandedChanged(bool value)
    {
        UpdateToggleIcon();
    }

    private void UpdateToggleIcon()
    {
        // Find the correct icon resource from the application's resources
        // based on the current state.
        string iconKey = IsPlayerViewExpanded ? "MinimizeIcon" : "RestoreIcon";

        if (Application.Current?.TryFindResource(iconKey, out object? resource) == true && resource is StreamGeometry geometry)
        {
            ToggleIconData = geometry;
        }
    }

    partial void OnIsClipboardMonitoringEnabledChanged(bool value)
    {
        if (clipboardMonitor != null) clipboardMonitor.IsEnabled = value;
        Console.WriteLine($"Clipboard monitoring is now {(value ? "ON" : "OFF")}");

        if (settings != null)
        {
            settings.AutoRead = value;
            settingsService?.Save(settings);
        }
    }

    private async Task<List<TTSResult>> CallTtsEngineAsync(string[] clipboardText, bool toFile = false)
    {
        List<TTSResult> messages = new();
        // Attempt to send and receive TTS from Backend
        int attemptsRemaining = 5;
        while (attemptsRemaining > 0)
        {
            bool fail = false;
            foreach (var text in clipboardText)
            {
                if (stopped) break;
                if (string.IsNullOrWhiteSpace(text)) continue;
                try
                {
                    Console.WriteLine("TTS engine send.");
                    loading = player!.GetPlayStatus() == IPlayer.SoundStatus.Stopped;
                    TTSResult message = await ttsService?.GenerateSpeechAsync(text, Voices[VoiceName] != "Python" ? Voices[VoiceName] : (sampleVoice ?? "Invalid"))!;
                    if (message.MessageType != "Failed")
                    {
                        if (!toFile)
                        {
                            if (!stopped) // This is for wait someone stops the playback wait Python is still generating.
                                player?.AddToQueue(message);
                            loading = false;
                        }
                        else
                        {
                            messages.Add(message);
                        }
                    }
                    else
                        throw new InvalidDataException("The TTS engine failed to generate a message.");
                }
                catch (Exception e)
                {
                    // If an error happens, the clipboard to TTS process could have partially completed but is in a bad state.
                    // If it was allowed to play the whole list in the queue, the bad message that contains the failed type would throw an exception.
                    // This happens when the player tries to add an invalid empty short array (audioSamples[0]) to the SoundBuffer and attempts to play.
                    // The messages must be cleared to prevent errors.
                    // EchoGarden has in the past sent bad data even though it uses MessagePack and not Json.
                    // Python? not sure how bad it would fail but this accounts for anything.
                    messages.Clear();
                    await handler?.ErrorPlayer(0, $"There was a connection fault with the backend. {e.Message}")!;
                    attemptsRemaining--;
                    if (attemptsRemaining == 0)
                        StopTts();
                    fail = true;
                    break;
                }
            }
            if (fail)
                continue;
            attemptsRemaining = 0;
        }
        return messages;
    }
    
    // --- Commands (Generated by CommunityToolkit) ---

    [RelayCommand]
    private void TogglePlayerView()
    {
        IsPlayerViewExpanded = !IsPlayerViewExpanded;
    }

    [RelayCommand/*(CanExecute = nameof(CanPlay))*/]
    private async Task PlayTtsAsync()
    {
        if (player != null && player.GetPlayStatus() == IPlayer.SoundStatus.Stopped)
        {
            stopped = false;
            
            if (string.IsNullOrEmpty(VoiceName) || !Voices.ContainsKey(VoiceName))
            {
                await handler?.ErrorPlayer(0, "A valid voice is not selected.")!;
                // Reset state and exit the method safely.
                stopped = true;
                return;
            }
            
            string[]? clipboardText = await clipboardService?.GetClipboard()!;
            if (clipboardText is null || clipboardText.Length == 0)
            {
                stopped = true;
                return;
            }

            PlayButtonText = "Pause";
            CanStop = true;
            
            // Don't await on this call. If awaited, it keeps holding the enabled state hostage making the button disabled even when loading is done.
            // Any background processing can continue when the player starts playing.
            _ = CallTtsEngineAsync(clipboardText); 
        }
        else if (player != null && player.GetPlayStatus() == IPlayer.SoundStatus.Playing)
        {
            player.Pause();
        }
        else if (player != null && player.GetPlayStatus() == IPlayer.SoundStatus.Paused)
        {
            player.Play();
        }
    }

    [RelayCommand(CanExecute = nameof(CanStop))]
    private void StopTts()
    {
        stopped = true;
        if (player != null && player.GetPlayStatus() != IPlayer.SoundStatus.Stopped)
        {
            player.Stop();
            CanStop = false;
            loading = false;
        }
    }

    [RelayCommand]
    private async Task SetTtsVoiceAsync(IStorageProvider? storageProvider)
    {
        if (storageProvider is null) return; // Cannot save without it
        var file = await fileService?.LoadFileAsync(storageProvider)!;
        if (file.Count > 0 && file[0]?.Path.LocalPath is { } path)
            SampleVoice = path;
        else
            SampleVoice = String.Empty;
    }
    
    [RelayCommand]
    private async Task SaveTtsAsync(IStorageProvider? storageProvider) // Pass the provider here
    {
        if (storageProvider is null) return; // Cannot save without it
        if (player != null && player.GetPlayStatus() != IPlayer.SoundStatus.Stopped)
        {
            player.Stop();
            CanStop = false;
        }
        stopped = false;
        string[]? clipboardText = await clipboardService?.GetClipboard()!;
        if (clipboardText is null || clipboardText.Length == 0)
        {
            stopped = true;
            return;
        }
        var allAudioBytes = new List<byte>();
        int sampleRate = 0;
        foreach (var message in await CallTtsEngineAsync(clipboardText, true))
        {
            if (message.MessageType != "Failed")
            {
                allAudioBytes.AddRange(message.AudioBuffer);
                sampleRate = message.BitRate;
            }
            else
            {
                StopTts();
            }
        }
        stopped = true; 
        if (allAudioBytes.Any() && sampleRate > 0)
        {
            // Pass the storageProvider to the service method
            var file = await fileService?.SaveFileAsync(storageProvider)!;
            if (file?.Path.LocalPath is { } path)
            {
                var rawData = allAudioBytes.ToArray();
                var extension = Path.GetExtension(path).ToLower();

                switch (extension)
                {
                    case ".mp3":
                        SaveAsMp3(path, rawData, sampleRate);
                        break;
                    case ".ogg":
                        SaveAsOgg(path, rawData, sampleRate);
                        break;
                    case ".wav":
                    default:
                        SaveAsWav(path, rawData, sampleRate);
                        break;
                }
            }
        }
    }

    private void SaveAsWav(string path, byte[] pcmData, int sampleRate)
    {
        var format = new WaveFormat(sampleRate, 16, 1); // Mono, 16-bit
        using var writer = new WaveFileWriter(path, format);
        writer.Write(pcmData, 0, pcmData.Length);
    }

    private void SaveAsMp3(string path, byte[] pcmData, int sampleRate)
    {
        // LameMP3FileWriter works almost exactly like WaveFileWriter
        // 128kbps is a standard bitrate for TTS
        var format = new WaveFormat(sampleRate, 16, 1);
        using var writer = new LameMP3FileWriter(path, format, LAMEPreset.STANDARD);
        writer.Write(pcmData, 0, pcmData.Length);
    }

    private void SaveAsOgg(string path, byte[] pcmData, int sampleRate)
    {
        // OggVorbisEncoder needs Float samples, not Bytes. 
        // We must convert 16-bit PCM Bytes -> Float[]
        
        // 1. Convert Bytes to Shorts
        short[] shortSamples = new short[pcmData.Length / 2];
        Buffer.BlockCopy(pcmData, 0, shortSamples, 0, pcmData.Length);

        // 2. Convert Shorts to Floats (-1.0 to 1.0)
        float[] floatSamples = new float[shortSamples.Length];
        for (int i = 0; i < shortSamples.Length; i++)
        {
            floatSamples[i] = shortSamples[i] / 32768f;
        }

        // 3. Setup Ogg Encoder
        // '1' is the number of channels (Mono)
        var info = VorbisInfo.InitVariableBitRate(1, sampleRate, 0.5f); 
        
        // 4. Encode
        // We create a generic "serial number" for the stream
        var serial = new Random().Next();
        var oggStream = new OggStream(serial);
        
        // Create the file
        using var fileStream = new FileStream(path, FileMode.Create, FileAccess.Write);
        
        // Add header
        var header = HeaderPacketBuilder.BuildInfoPacket(info);
        var comments = HeaderPacketBuilder.BuildCommentsPacket(new Comments());
        var books = HeaderPacketBuilder.BuildBooksPacket(info);
        
        oggStream.PacketIn(header);
        oggStream.PacketIn(comments);
        oggStream.PacketIn(books);
        
        FlushPages(oggStream, fileStream, true);

        // Feed Data
        var processingState = ProcessingState.Create(info);
        processingState.WriteData(new [] { floatSamples }, floatSamples.Length); // Pass array of arrays (channels)
        
        while (!oggStream.Finished && processingState.PacketOut(out OggPacket packet))
        {
            oggStream.PacketIn(packet);
            FlushPages(oggStream, fileStream, false);
        }
    }

    private void FlushPages(OggStream oggStream, Stream output, bool force)
    {
        while (oggStream.PageOut(out OggPage page, force))
        {
            output.Write(page.Header, 0, page.Header.Length);
            output.Write(page.Body, 0, page.Body.Length);
        }
    }
    
    [RelayCommand]
    private void CloseProgram()
    {
        ttsService?.StopBackend();
        // A cleaner exit might be to call a method on the ApplicationLifetime
        Environment.Exit(0);
    }
    
    // --- Background Polling Logic ---
    private void StartStatusPolling(CancellationToken token)
    {
        _ = Task.Run(async () =>
        {
            var timer = new PeriodicTimer(TimeSpan.FromMilliseconds(100));
            while (await timer.WaitForNextTickAsync(token))
            {
                if (token.IsCancellationRequested) break;

                // --- Step 1: Get all the data on the background thread ---
                if (player != null)
                {
                    var currentStatus = player.GetPlayStatus();
                    var currentWord = player?.GetWord();

                    // --- Step 2: Schedule the UI updates to run on the UI thread ---
                    Dispatcher.UIThread.Post(() =>
                    {
                        WordStatus = !loading ? currentWord ?? "Word: ..." : "Word: Loading...";
                        CanStop = currentStatus != IPlayer.SoundStatus.Stopped;
                        CanPlay = !loading;
                        PlayButtonText = currentStatus == IPlayer.SoundStatus.Playing ? "Pause" : "Play";
                    });
                }
            }
        }, token);
    }

    // --- Helper Methods ---
    private void PopulateVoices(bool isPython)
    {
        if (!isPython)
        {
            CustomVoice = false;
            AddVoice("Amy low (Female)", "en_US-amy-low", "Amy Save.ogg");
            AddVoice("Amy medium (Female)", "en_US-amy-medium", "Amy Save.ogg");
            AddVoice("Kathleen (Female)", "en_US-kathleen-low", "Kathleen Save.ogg");
            AddVoice("Lessac low (Female)", "en_US-lessac-low", "Lessac Save.ogg");
            AddVoice("Lessac medium (Female)", "en_US-lessac-medium", "Lessac Save.ogg");
            AddVoice("Lessac high (Female)", "en_US-lessac-high", "Lessac Save.ogg");
            AddVoice("Libritts", "en_US-libritts-high", "Libritts Save.ogg");
            AddVoice("Ryan low (Male)", "en_US-ryan-low", "Ryan Save.ogg");
            AddVoice("Ryan medium (Male)", "en_US-ryan-medium", "Ryan Save.ogg");
            AddVoice("Ryan high (Male)", "en_US-ryan-high", "Ryan Save.ogg");
            AddVoice("Joe (Male)", "en_US-joe-medium", "Joe Save.ogg");
            AddVoice("Kusal (Male)", "en_US-kusal-medium", "Kusal Save.ogg");
            AddVoice("Arctic", "en_US-arctic-medium", "Arctic Save.ogg");
            AddVoice("arctic 12", "en_US-l2arctic-medium", "Arctic12 Save.ogg");
        }
        else
        {
            CustomVoice = true;
            AddVoice("Default", "Python", "N/A");
        }
    }

    private void AddVoice(string name, string id, string saveName)
    {
        VoiceList.Add(name);
        Voices.Add(name, id);
        SaveFileAudioNames.Add(name, saveName);
    }
    
    // --- Cleanup ---
    public void Dispose()
    {
        cts.Cancel(); // Signal the polling task to stop
        cts.Dispose();
        if (clipboardMonitor != null) clipboardMonitor.ClipboardTextChanged -= OnClipboardTextChanged;
        GC.SuppressFinalize(this);
    }
}